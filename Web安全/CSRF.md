## CSRF

CSRF跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在攻击网站已经获取的注册凭证，绕过后台用户验证，达到冒充用户对攻击的而昂着执行某项操作的目的。

比如在你登录了A网站之后，短时间内(未登出状态下)点击进入恶意B网站，此时B网站可能以隐藏表单(post类型)或者img的src（POST请求）向后端以你的名义发起恶意请求

一个典型的CSRF攻击有着如下的流程：

- 受害者登录a.com，并保留了登录凭证(cookie)
- 攻击者引诱受害者访问b.com
- b.com向a.com发送一个请求：a.com/act=xx.浏览器会默认携带a.com的Cookie.
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作

#### CSRF特点

- 攻击者一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止发生
- 攻击者利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据
- **这个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”**
-  CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险 

#### 防范

- 尽量使用POST
- 加入验证码（手机验证码、拼图）
- 验证referer,发送请求源（同源策略）
- 在表单或头信息中传递token（随机性token），token存储在服务端，服务端通过拦截器验证有效，校验失败拒绝请求
  - CSRF之所以能成功，是因为服务器误把攻击者发送的请求当作了用户自己的请求，那么我们可以要求所有用户请求携带一个CSRF无法获到得Token。服务器通过校验请求是否携带正确token，来把正常请求和攻击请求分开
  - 首先用户打开页面的时候，服务器需要给这个用户生成一个Token，该token最好存在服务器端。页面提交时验证token是否有效。
- SameSite:对cookie设置SameSite属性。该属性表示cookie不随着跨域请求发送，但该属性目前并不是所有浏览器都兼容