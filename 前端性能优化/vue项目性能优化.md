### Vue项目性能优化

> Vue框架通过数据双向绑定和虚拟DOM技术，帮我们处理了前端开发中最脏最累的DOM操作部分，我们不需要考虑如何操作DOM以及如何高效的操作DOM；但Vue项目中仍存在项目优化、Webpack编译配置优化等问题，所以我们仍要去关注Vue项目性能方面的优化
>
> 主要从以下方面谈起Vue性能优化
>
> - Vue代码层面优化
> - webpack配置层面的优化
> - 基础Web技术层面的优化



### 一、代码层面优化

#### 1.1 v-if与v-show

v-if是真正的条件渲染，也是惰性的，他会切薄在切换过程中条件块内的事件监听器和子组件适当是被销毁和重建；但在初始渲染条件为假使，则什么有不做—直到条件为真，才会开始渲染条件块

v-show则不管初始条件是什么，元素总会被渲染，并且只是简单地基于CSS的dispaly属性进行切换

所以，v-if适用于运行时条件很少发生改变的情况下，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景。

#### 1.2 v-for加key值

在列表数据进行遍历渲染时，需要为每一项的item是指一个唯一的key值，（因为vue在进行列表渲染时会遵守就地复用的原则，当没有唯一key值时，可能会造成数据的混乱）

作用：

- 提高渲染性能，方便Vue内部机制精准的找到该条件列表数据。key能追踪到每个节点的身份，当state更新时，新的状态和旧的状态对比，较快的定位到diff，从而重用和重排，不会随意的销毁
- 避免数据混乱

#### 1.3 v-for与v-if不要一起用，必要时使用计算属性

v-for比v-if优先级高，如果每一此都要遍历整个数组然后再决定是否if渲染的话，将会影响速度，尤其时当只需要渲染很小一部分的时候，必要情况下应该替换成computed属性。

推荐

```jsx
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
 return user.isActive
    })
  }
}

//不推荐
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
```

#### 1.4 computed、methods和watched使用

methods：只要每次模板一变化，将会重新视图渲染，开销较大，每次一更新，方法将会重新执行（不擅长处理数据逻辑关系，只提供可调用函数）

computed：具有缓存，依赖其他属性值，只有他依赖的属性值发生变化，下一次获取computed的值才会重新计算（擅长处理一个数据受多个数据影响）

watch：更多的是观察作用，类似于某些数据的监听回调，每当监听的数据发生变化时都会执行回调进行后续操作（擅长处理一个数据影响多个数据，再数据变化时指向异步或开销较大的操作）

#### 1.5 长列表性能优化`Object.freeze`

vue会通过`Object.defineProperty`来对数据进行劫持，实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要Vue来劫持我们的数据，在大量数据展示的情况下，就可以很明显减少组件初始化的时间。使用`Object.freeze`可以冻结一个对象，一旦被冻结对象就再也不能被修改了

#### 1.6 事件销毁

在组件销毁时，对一些定时器进行清空，解除事件绑定，以免造成内存泄漏（beforeDestroy）

#### 1.7 图片懒加载

对于图片过多的页面，为了加速页面加载速度，对于页面内未出现在可是区域内的托爱你先不做加载，等到滚动到可是区域后再去加载。这样对于页面加载性能上有很大的提升，也提升用户体验

#### 1.8 路由懒加载

不同路由对应的组件分割成不同代码块，然后当路由被访问的时候才加载对应的组件，大大提高了收评显示速度

#### 1.9 第三方组件按需引入

借助`babel-plugin-component`

#### 1.10 优化无限列表性能

 如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。 

### 二、webpack层面优化

#### 2.1 Webpack对图片进行压缩

#### 2.2 提取公共代码

- CommonsChunkPlugin

#### 2.3 优化SourceMap

- source Map：在项目打包之后，经过压缩、去除多余空格、babel编译后，最终编译得到的代码和源代码差别很大，当有bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，因此sourceMap出现了，他就是解决不好调试代码的问题



### 三、基础Web技术优化

#### 3.1 开启gzip压缩

- 最早用于UNIX系统的文件压缩。压缩效率非常高，通常可到到70%的压缩率
- 开启之后，response header中可看到`Cotent-Encoding:gzip`

#### 3.2 浏览器缓存

 为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存） 

#### 3.3 CDN的使用

 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。 





----





### 项目部署

使用vue\react\angular等技术开发过程中，经常会遇到以下问题：

1. 首屏加载慢
2. 每一次更新的需要清除浏览器缓存才能看到效果

以下缓存基于vue-cli3

路由使用按需加载后，打包生成的文件，每一个路由页面对应一个js和css文件，入口main.js及其依赖则打包成了app.js和app.css，公共依赖都放到了chunk-vendoers.js

- **`vue-cli3`打包生成的文件名带`hash`值的作用：为了缓存的最优体验**

- 打包生成的js/css/img等文件名都带有hash值，当源文件内容改变时，重新打包后对应文件的hash值也会发生变化，而其他没有修改的文件，打包后的hash值都不会改变。
- 使用hash是为了消除缓存带来的影响，但所有文件都不缓存肯定不是一个很好的解决方案

**http缓存：**

1. HTTP1.0是通过expires（文件过期时间）和Last-Modified（最近修改时间）来告诉浏览器进行缓存的，expires过期控制不稳定，且浏览器可以随意修改本地时间，导致缓存不精确
2. HTTP1.1通过Cache-Contorl和Etag（版本号）进行缓存控制。 浏览器先检查 `Cache-Control`，如果有，则以 `Cache-Control` 为准，忽略 `Expires`。如果没有 `Cache-Control`，则以 `Expires` 为准。 



