## 创建对象的方法

#### 1、工厂模式

```javascript
function createPerson(name,age){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.sayNmae = function(){
        alert(this.name);
    }
    return 0;
}

var person1 = createPerson('bob',29);
```

​	这种模式抽象了创建具体对象的方法，由于js无法直接创建对象，开发人员以函数封装特定接口以创建对象

**缺点**

​	**工厂模式虽然简化了创建多个相似实例，但未解决对象识别问题，不知道该实例到底时哪个对象创建的**



#### 2、构造函数模式

```javascript
function Person(name,age){
    this.name = name;
    this.age = age
}
//创建实例时需要使用new关键字
var person1 = new Person('bob',19)

alert(person1.constructor == Person)//此处的constructor是原型对象上的属性，指向构造函数
```

与工厂模式相比不同之处：

1. 没有显示的创建对象

2. 直接将属性和方法赋值给this

    3. 没有return语句

使用构造函数实例化创造对象时，必须使用**new操作符**，关于new操作符使用时经历的4个步骤一定要清楚（面试高频题！！）

- 创建一个空对象
- 链接到原型（```obj.__proto__  = fn.prototype```）
- 将构造函数的作用域赋值给新对象（绑定this），this指向这个对象，执行构造函数中代码（为这个新对象添加属性）
- 返回新对象

**此时创造的实例对象可以找到它的特定类型**，因为每一个实例有一个constructor属性(其实时原型对象上的属性)，该属性指向构造函数（特定类型）

**缺点**

​    **每个方法的要在每个实例上创建一遍，因为js函数就是对象，每定义一个函数，就实例化一个对象，执行相同任务的function，实例化多个确实没用\****



#### 3、原型模式

![](E:\找工作\知识点总结\img\原型.png)

- prototype

  我们每创建一个函数的有一个``prototype``属性，只有函数才有这个属性，它是一个指针，指向一个对象，这个对象就是**原型对象**，用途是包含可以由特定类型的所有实例共享的属性和方法。

  - ``prototype``如何产生
    - 当我们声明一个函数时，这个属性就会被自动创建了```function Foo(){}```
  - 这个属性的值也是一个对象，只有一个属性``constructor``

- ``__proto__``

  这是每个对象的有的隐式原型属性，指向创建该对象的构造函数的原型对象。 其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 `_proto_` 来访问。 

   因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 `_proto_ `将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。 

  - 如何产生
    - 当我们使用new操作符时，生成的实例对象就拥有了``__proto__``属性

- 构造函数

  在创建对象时，就会生成一个``prototype``，指向一个对象，就是原型对象

- 原型对象

  原型对象最开始只有一个属性——``constructor``，指向构造函数，可以通过``obj.prototype.``添加所有实例共享的方法和属性，此时的原型对象就拥有多个属性，且这些属性所有实例共享。

- 实例对象

  使用new操作符创建出来的实例对象都拥有一个内部属性（此时构造函数上的属性也已经添加到实例对象上），该属性指向原型对象，是因为所有实例要继承原型对象上的方法

##### 查找某对象属性

- 当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性

        1.  搜索首先从对象实例本身出发
                    1.  若在对象实例中找到具有给定名字的属性，则返回该属性的值；
                    2.  若没有找到，则继续搜索指针指向的原型对象；
        2.   执行第二次搜索，搜索原型对象
                    1.  若在原型对象中找到这个属性，则返回该属性的值；
                    2.  若没有找到，则返回udefined

**不能通过对象实例重写原型中值**

如果我们在对象实例中添加了一个属性，而该属性与实例原型中的一个属性同名，则将会在实例对象中创建该属性，该属性会***\*屏蔽\****原型中属性

***\*in(无论是实例还是原型上方法都返回true)、hasOwnPrototy()只有存在于对象实例中时，才会返回true`*****\***

**缺点**

​	原型模式最大的问题是由其共享本质所导致的，对于包含引用类型的知道属性来说，问题较为突出，如数组，修改其中一个实例的引用类型，会导致在另一个实例中也表现出来



#### 4、组合使用构造函数和原型模式

**构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性**

每个实例都会有一份自己的实例副本，但同时又共享着对方法的引用，最大限度的节省了内存。同时还支持向构造函数传递参数



#### 5、ES6 class关键字定义类

```javascript
class Person{
    constructor(age,name){
        this.age = age;
        this.name = name;
    }
    sayName(){
        console.log(this.name);
    }
}
var person1 = new Person(11, '小白');
var person2 = new Person(12, '小黑');
```

class定义的类上有个constructor方法，这就是构造函数，该方法会返回一个实例对象，this代表的就是实例对象，这跟上边的构造函数模式类似

此外，class上的方法都是定义在prototype上的，这跟原型模式有有一些类似

